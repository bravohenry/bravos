<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <link rel="stylesheet" href="/fonts/fonts.css">
    <!-- ts=1762741787003 --> 
    
    
<script>
  (function () {
    var CHANNEL = "ryos-applet-auth";
    var MAX_ATTEMPTS = 10;
    var REQUEST_INTERVAL_MS = 200;
    var TIMEOUT_MS = 2000;

    if (typeof window === "undefined") {
      return;
    }

    var currentAuthPayload = null;
    var authResolved = false;
    var resolveAuth = function (payload) {};

    var authReady = new Promise(function (resolve) {
      resolveAuth = function (payload) {
        if (authResolved) {
          return;
        }
        authResolved = true;
        currentAuthPayload = payload || null;
        try {
          window.__RYOS_APPLET_AUTH = currentAuthPayload || {};
        } catch (err) {
          console.warn("[ryOS] Failed to expose applet auth payload:", err);
        }
        resolve(null);
      };
    });

    var attempts = 0;
    var requestOnce = function () {
      try {
        if (window.parent) {
          window.parent.postMessage({ type: CHANNEL, action: "request" }, "*");
        }
      } catch (err) {
        console.warn("[ryOS] Applet auth request failed:", err);
      }
    };

    requestOnce();
    var requestTimer = setInterval(function () {
      attempts += 1;
      if (authResolved || attempts >= MAX_ATTEMPTS) {
        clearInterval(requestTimer);
        return;
      }
      requestOnce();
    }, REQUEST_INTERVAL_MS);

      setTimeout(function () {
        if (!authResolved) {
          clearInterval(requestTimer);
          resolveAuth(null);
        }
      }, TIMEOUT_MS);

      window.addEventListener("message", function (event) {
        var data = event && event.data;
        if (!data || data.type !== CHANNEL || data.action !== "response") {
          return;
        }
        clearInterval(requestTimer);
        if (authResolved) {
          currentAuthPayload = data.payload || null;
          try {
            window.__RYOS_APPLET_AUTH = currentAuthPayload || {};
          } catch (err) {
            console.warn("[ryOS] Failed to refresh applet auth payload:", err);
          }
          return;
        }
        resolveAuth(data.payload || null);
      });

      if (window.__RYOS_APPLET_FETCH_PATCHED) {
        return;
      }

      var originalFetch = window.fetch.bind(window);
      window.__RYOS_APPLET_FETCH_PATCHED = true;
      window.__RYOS_ORIGINAL_FETCH = originalFetch;

      window.fetch = function (input, init) {
        return authReady.then(function () {
          var payload = currentAuthPayload;
          if (!payload || (!payload.username && !payload.authToken)) {
            return originalFetch(input, init);
          }

          var extraHeaders = {};
          if (payload.username) {
            extraHeaders["X-Username"] = payload.username;
          }
          if (payload.authToken) {
            extraHeaders["Authorization"] = "Bearer " + payload.authToken;
          }

          var shouldAugment = function (url) {
            try {
              var resolved = new URL(url, document.baseURI || window.location.origin);
              return resolved.pathname === "/api/applet-ai";
            } catch (err) {
              return false;
            }
          };

          var mergeHeaders = function (primary, secondary) {
            var headers = new Headers(primary || undefined);
            if (secondary) {
              new Headers(secondary).forEach(function (value, key) {
                headers.set(key, value);
              });
            }
            Object.keys(extraHeaders).forEach(function (key) {
              var value = extraHeaders[key];
              if (value) {
                headers.set(key, value);
              }
            });
            return headers;
          };

          var url;
          if (typeof input === "string" || input instanceof URL) {
            url = input.toString();
          } else if (input instanceof Request) {
            url = input.url;
          }

          if (!url || !shouldAugment(url)) {
            return originalFetch(input, init);
          }

          if (input instanceof Request) {
            var headers = mergeHeaders(input.headers, init && init.headers);
            var augmentedRequest = new Request(input, { headers: headers });
            return originalFetch(augmentedRequest);
          }

          var headersForInit = mergeHeaders(init && init.headers);
          var augmentedInit = init ? Object.assign({}, init) : {};
          augmentedInit.headers = headersForInit;
          return originalFetch(input, augmentedInit);
        });
      };
  })();
</script>

    <script type="module" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.174.0/three.module.min.js"></script>
  <script src="https://cdn.tailwindcss.com/3.4.16"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            sans: ["Geneva-12", "ArkPixel", "SerenityOS-Emoji", "sans-serif"],
            mono: ["Monaco", "ArkPixel", "SerenityOS-Emoji", "ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", "Liberation Mono", "Courier New", "monospace"],
            serif: ["Mondwest", "Yu Mincho", "Hiragino Mincho Pro", "Georgia", "Palatino", "SerenityOS-Emoji", "serif"],
            emoji: ["SerenityOS-Emoji", "AppleColorEmoji", "AppleColorEmojiFallback"],
            'geneva': ["Geneva-12", "ArkPixel", "SerenityOS-Emoji", "system-ui", "-apple-system", "sans-serif"],
            'mondwest': ["Mondwest", "Yu Mincho", "Hiragino Mincho Pro", "Georgia", "Palatino", "Yu Mincho", "Hiragino Mincho Pro", "serif"],
            'neuebit': ["NeueBit", "ArkPixel", "SerenityOS-Emoji", "Helvetica", "Arial", "Hiragino Sans", "sans-serif"],
            'monaco': ["Monaco", "ArkPixel", "SerenityOS-Emoji", "monospace"],
            'jacquard': ["Jacquard", "Yu Mincho", "Hiragino Mincho Pro", "Georgia", "Palatino", "serif"]
          }
        }
      }
    }
  </script>
  <style>
    * {
      box-sizing: border-box;
      
    }
    html, body {
      margin: 0;
      overflow-x: auto; /* Allow horizontal scroll if content overflows */
      width: 100%;
      height: 100%;
      max-width: 100%; /* Prevent body from exceeding viewport width */
      
    }
    
    /* Ensure pre doesn't break layout */
    pre {
      white-space: pre-wrap; /* Allow wrapping */
      word-break: break-all; /* Break long words */
    }
  </style>
  
  <!-- Move click interceptor script to head for earlier execution -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      document.addEventListener('click', function(event) {
        var targetElement = event.target.closest('a');
        // Only intercept if it's a valid link and NOT inside the draggable toolbar
        if (targetElement && targetElement.href && !targetElement.closest('[data-drag-controls]')) {
          event.preventDefault();
          event.stopPropagation();
          try {
            // Resolve relative URLs against the document's base URI (if set) or window location
            const absoluteUrl = new URL(targetElement.getAttribute('href'), document.baseURI || window.location.href).href;
            // Use a specific message type for AI HTML navigation
            window.parent.postMessage({ type: 'aiHtmlNavigation', url: absoluteUrl }, '*');
            console.log('Intercepted link click:', absoluteUrl);
          } catch (e) { console.error("Error resolving/posting URL:", e); }
        }
      }, true); // Use capture phase to intercept early
    });
    
    // Also add immediate execution version for documents that load quickly
    // This helps ensure we don't miss any clicks during initial page load
    (function() {
      document.addEventListener('click', function(event) {
        var targetElement = event.target.closest('a');
        // Only intercept if it's a valid link and NOT inside the draggable toolbar
        if (targetElement && targetElement.href && !targetElement.closest('[data-drag-controls]')) {
          event.preventDefault();
          event.stopPropagation();
          try {
            // Resolve relative URLs against the document's base URI (if set) or window location
            const absoluteUrl = new URL(targetElement.getAttribute('href'), document.baseURI || window.location.href).href;
            // Use a specific message type for AI HTML navigation
            window.parent.postMessage({ type: 'aiHtmlNavigation', url: absoluteUrl }, '*');
            console.log('Intercepted link click (immediate handler):', absoluteUrl);
          } catch (e) { console.error("Error resolving/posting URL:", e); }
        }
      }, true); // Use capture phase to intercept early
    })();
  </script>
 
</head>
<body>
  <div class="w-full min-h-screen bg-white font-geneva p-4">
  <div class="text-center mb-6 mt-8">
    <div id="headerEmoji" class="mx-auto mb-3 h-[120px] w-[120px] flex items-center justify-center transition-all duration-500">
      <span class="text-6xl">üòä</span>
    </div>
    
    <div id="emojiActions" class="hidden opacity-0 transition-opacity duration-300">
      <div class="flex gap-2">
        <button id="downloadBtn" class="flex-1 bg-white border border-neutral-200 rounded-lg px-4 py-3 text-neutral-600 hover:bg-neutral-50 active:bg-neutral-100 transition-colors">
          <span id="downloadText">download png</span>
        </button>
        <button id="clearBtn" class="flex-1 bg-white border border-neutral-200 rounded-lg px-4 py-3 text-neutral-600 hover:bg-neutral-50 active:bg-neutral-100 transition-colors">
          clear
        </button>
      </div>
    </div>
  </div>

  <div class="space-y-4">
    <div id="rateLimitBanner" class="hidden bg-black text-white rounded-lg p-4">
      <div class="text-sm font-bold mb-1">rate limit reached</div>
      <div id="rateLimitMessage" class="text-sm"></div>
    </div>

    <div class="bg-white border border-neutral-200 rounded-lg overflow-hidden">
      <div class="relative">
        <textarea id="prompt" placeholder="describe your emoji..." class="w-full px-4 py-3 pr-12 text-neutral-800 focus:outline-none resize-none h-24"></textarea>
        
        <input type="file" id="imageUpload" accept="image/*" class="hidden">
        <button id="uploadBtn" class="absolute bottom-3 right-3 w-8 h-8 flex items-center justify-center rounded hover:bg-neutral-100 active:bg-neutral-200 transition-colors" title="add context image">
          <svg id="uploadIcon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" class="text-neutral-400">
            <rect x="2" y="4" width="16" height="13" rx="2" stroke="currentColor" stroke-width="1.5"/>
            <circle cx="7" cy="8.5" r="1.5" fill="currentColor"/>
            <path d="M2 14L6 10L9 13L13 9L18 14V15C18 16.1046 17.1046 17 16 17H4C2.89543 17 2 16.1046 2 15V14Z" fill="currentColor" fill-opacity="0.3"/>
          </svg>
          <svg id="uploadedIcon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" class="text-blue-600 hidden">
            <rect x="2" y="4" width="16" height="13" rx="2" stroke="currentColor" stroke-width="1.5"/>
            <circle cx="7" cy="8.5" r="1.5" fill="currentColor"/>
            <path d="M2 14L6 10L9 13L13 9L18 14V15C18 16.1046 17 16 17H4C2.89543 17 2 16.1046 2 15V14Z" fill="currentColor"/>
          </svg>
        </button>
      </div>
    </div>

    <div class="bg-white border border-neutral-200 rounded-lg overflow-hidden">
      <button id="generateBtn" class="w-full px-4 py-3 text-neutral-600 hover:bg-neutral-50 active:bg-neutral-100 transition-colors">
        <span id="btnText">generate</span>
      </button>
    </div>

    <div id="error" class="hidden bg-red-50 border border-red-200 rounded-lg overflow-hidden">
      <div class="p-4">
        <div class="text-sm font-bold text-red-700 mb-2">error</div>
        <div id="errorMsg" class="text-sm text-red-600 mb-2"></div>
        <details class="text-xs text-red-500 mt-3">
          <summary class="cursor-pointer hover:text-red-700">debug info</summary>
          <pre id="errorDebug" class="mt-2 p-2 bg-red-100 rounded overflow-x-auto"></pre>
        </details>
        <details class="text-xs text-red-500 mt-2">
          <summary class="cursor-pointer hover:text-red-700">request sent</summary>
          <pre id="requestDebug" class="mt-2 p-2 bg-red-100 rounded overflow-x-auto"></pre>
        </details>
        <details class="text-xs text-red-500 mt-2">
          <summary class="cursor-pointer hover:text-red-700">response received</summary>
          <pre id="responseDebug" class="mt-2 p-2 bg-red-100 rounded overflow-x-auto"></pre>
        </details>
      </div>
      <button id="retryBtn" class="w-full px-4 py-3 text-red-600 hover:bg-red-100 transition-colors border-t border-red-200">
        retry
      </button>
    </div>
  </div>
</div>

<style>
@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}

.shimmer-overlay {
  position: relative;
  overflow: hidden;
}

.shimmer-overlay::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, rgba(240,240,240,0.8) 25%, rgba(224,224,224,0.8) 50%, rgba(240,240,240,0.8) 75%);
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
}

.scale-up {
  animation: scaleUp 0.4s ease-out forwards;
}

@keyframes scaleUp {
  from {
    width: 120px;
    height: 120px;
  }
  to {
    width: 240px;
    height: 240px;
  }
}
</style>

<script>
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let generatingMelodyInterval = null;

function playSound(type) {
  const now = audioCtx.currentTime;
  
  if (type === 'click') {
    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    
    osc1.type = 'sine';
    osc2.type = 'sine';
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(2000, now);
    
    osc1.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    
    osc1.frequency.setValueAtTime(1200, now);
    osc2.frequency.setValueAtTime(1800, now);
    gain.gain.setValueAtTime(0.15, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
    
    osc1.start(now);
    osc2.start(now);
    osc1.stop(now + 0.08);
    osc2.stop(now + 0.08);
    
  } else if (type === 'upload') {
    const osc = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    
    osc.type = 'sine';
    osc2.type = 'triangle';
    filter.type = 'bandpass';
    filter.frequency.setValueAtTime(800, now);
    filter.Q.setValueAtTime(3, now);
    
    osc.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    
    osc.frequency.setValueAtTime(650, now);
    osc.frequency.exponentialRampToValueAtTime(750, now + 0.05);
    osc2.frequency.setValueAtTime(975, now);
    osc2.frequency.exponentialRampToValueAtTime(1125, now + 0.05);
    
    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
    
    osc.start(now);
    osc2.start(now);
    osc.stop(now + 0.12);
    osc2.stop(now + 0.12);
    
  } else if (type === 'generate') {
    const notes = [
      { freq: 261.63, time: 0 },
      { freq: 329.63, time: 0 },
      { freq: 392.00, time: 0 },
      { freq: 523.25, time: 0.15 }
    ];
    
    notes.forEach(note => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      
      osc.type = 'triangle';
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(2500, now + note.time);
      filter.Q.setValueAtTime(1, now + note.time);
      
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      
      osc.frequency.setValueAtTime(note.freq, now + note.time);
      gain.gain.setValueAtTime(0, now + note.time);
      gain.gain.linearRampToValueAtTime(0.12, now + note.time + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.001, now + note.time + 0.35);
      
      osc.start(now + note.time);
      osc.stop(now + note.time + 0.35);
    });
    
  } else if (type === 'complete') {
    const chord = [
      { freq: 523.25, gain: 0.1 },
      { freq: 659.25, gain: 0.08 },
      { freq: 783.99, gain: 0.1 },
      { freq: 1046.5, gain: 0.06 }
    ];
    
    chord.forEach((note, i) => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      
      osc.type = 'triangle';
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(3000, now);
      filter.frequency.exponentialRampToValueAtTime(1500, now + 0.5);
      
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      
      osc.frequency.setValueAtTime(note.freq, now);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(note.gain, now + 0.03);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
      
      osc.start(now);
      osc.stop(now + 0.8);
    });
    
    const shimmer = audioCtx.createOscillator();
    const shimmerGain = audioCtx.createGain();
    shimmer.type = 'sine';
    shimmer.frequency.setValueAtTime(2093, now);
    shimmer.connect(shimmerGain);
    shimmerGain.connect(audioCtx.destination);
    shimmerGain.gain.setValueAtTime(0, now);
    shimmerGain.gain.linearRampToValueAtTime(0.04, now + 0.05);
    shimmerGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
    shimmer.start(now);
    shimmer.stop(now + 0.6);
    
  } else if (type === 'clear') {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    
    osc.type = 'sawtooth';
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(1200, now);
    filter.frequency.exponentialRampToValueAtTime(300, now + 0.3);
    filter.Q.setValueAtTime(5, now);
    
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    
    osc.frequency.setValueAtTime(800, now);
    osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
    gain.gain.setValueAtTime(0.08, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    
    osc.start(now);
    osc.stop(now + 0.3);
  }
}

function startGeneratingMelody() {
  if (generatingMelodyInterval) return;
  
  const melody = [
    { freq: 523.25, duration: 0.15, gain: 0.05 },
    { freq: 0, duration: 0.15, gain: 0 },
    { freq: 659.25, duration: 0.15, gain: 0.04 },
    { freq: 0, duration: 0.15, gain: 0 },
    { freq: 523.25, duration: 0.15, gain: 0.05 },
    { freq: 0, duration: 0.15, gain: 0 },
    { freq: 783.99, duration: 0.15, gain: 0.045 },
    { freq: 0, duration: 0.15, gain: 0 }
  ];
  
  let noteIndex = 0;
  
  function playNote() {
    const note = melody[noteIndex];
    
    if (note.freq > 0) {
      const now = audioCtx.currentTime;
      
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      
      osc.type = 'sine';
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(1800, now);
      filter.Q.setValueAtTime(0.5, now);
      
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      
      osc.frequency.setValueAtTime(note.freq, now);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(note.gain, now + 0.005);
      gain.gain.exponentialRampToValueAtTime(0.001, now + note.duration);
      
      osc.start(now);
      osc.stop(now + note.duration);
    }
    
    noteIndex = (noteIndex + 1) % melody.length;
  }
  
  playNote();
  generatingMelodyInterval = setInterval(playNote, 150);
}

function stopGeneratingMelody() {
  if (generatingMelodyInterval) {
    clearInterval(generatingMelodyInterval);
    generatingMelodyInterval = null;
  }
}

function formatTime(seconds) {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = seconds % 60;
  
  if (h > 0) {
    return `${h}h ${m}m`;
  } else if (m > 0) {
    return `${m}m ${s}s`;
  } else {
    return `${s}s`;
  }
}

let uploadedImage = null;
let requestData = null;
let responseData = null;
let generatedImageUrl = null;

function updateHeaderEmoji(imageUrl, animate = false) {
  const header = document.getElementById('headerEmoji');
  if (imageUrl) {
    header.classList.add('bg-neutral-100', 'rounded-lg', 'overflow-hidden');
    if (animate) {
      header.classList.add('scale-up');
    } else {
      header.classList.remove('scale-up');
      header.style.width = '240px';
      header.style.height = '240px';
    }
    header.innerHTML = `<img src="${imageUrl}" class="w-full h-full object-cover" draggable="true">`;
  } else {
    header.classList.remove('bg-neutral-100', 'rounded-lg', 'overflow-hidden', 'scale-up');
    header.style.width = '120px';
    header.style.height = '120px';
    header.innerHTML = '<span class="text-6xl">üòä</span>';
  }
}

function showHeaderShimmer(showOriginal = false) {
  const header = document.getElementById('headerEmoji');
  header.classList.add('bg-neutral-100', 'rounded-lg', 'overflow-hidden', 'scale-up');
  
  if (showOriginal && uploadedImage) {
    header.innerHTML = `<div class="shimmer-overlay w-full h-full" style="background-image: url('${uploadedImage}'); background-size: cover; background-position: center; background-repeat: no-repeat;"></div>`;
  } else {
    header.innerHTML = '<div class="shimmer-overlay w-full h-full bg-neutral-100"></div>';
  }
}

function showActions() {
  const actions = document.getElementById('emojiActions');
  actions.classList.remove('hidden');
  setTimeout(() => {
    actions.style.opacity = '1';
  }, 50);
}

function hideActions() {
  const actions = document.getElementById('emojiActions');
  actions.style.opacity = '0';
  setTimeout(() => {
    actions.classList.add('hidden');
  }, 300);
}

function resetAll() {
  playSound('clear');
  document.getElementById('prompt').value = '';
  document.getElementById('imageUpload').value = '';
  uploadedImage = null;
  generatedImageUrl = null;
  updateHeaderEmoji(null);
  hideActions();
  document.getElementById('error').classList.add('hidden');
  document.getElementById('rateLimitBanner').classList.add('hidden');
  document.getElementById('uploadIcon').classList.remove('hidden');
  document.getElementById('uploadedIcon').classList.add('hidden');
  document.getElementById('prompt').focus();
}

async function compressImage(file, maxWidth = 512, quality = 0.8) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        let width = img.width;
        let height = img.height;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        canvas.toBlob((blob) => {
          const compressedReader = new FileReader();
          compressedReader.onload = (ev) => {
            resolve({
              dataUrl: ev.target.result,
              size: blob.size,
              originalSize: file.size
            });
          };
          compressedReader.readAsDataURL(blob);
        }, 'image/jpeg', quality);
      };
      img.onerror = reject;
      img.src = e.target.result;
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

document.getElementById('uploadBtn').addEventListener('click', () => {
  playSound('click');
  document.getElementById('imageUpload').click();
});

document.getElementById('imageUpload').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (file) {
    const header = document.getElementById('headerEmoji');
    header.classList.add('bg-neutral-100', 'rounded-lg', 'overflow-hidden', 'scale-up');
    header.innerHTML = '<div class="shimmer-overlay w-full h-full bg-neutral-100"></div>';
    
    try {
      const compressed = await compressImage(file);
      uploadedImage = compressed.dataUrl;
      updateHeaderEmoji(uploadedImage, true);
      playSound('upload');
      
      const sizeMB = (compressed.size / 1024 / 1024).toFixed(2);
      const originalMB = (compressed.originalSize / 1024 / 1024).toFixed(2);
      console.log(`compressed ${originalMB}MB ‚Üí ${sizeMB}MB`);
      
      document.getElementById('uploadIcon').classList.add('hidden');
      document.getElementById('uploadedIcon').classList.remove('hidden');
    } catch (error) {
      console.error('compression failed:', error);
      updateHeaderEmoji(null);
    }
  }
});

document.getElementById('uploadBtn').addEventListener('contextmenu', (e) => {
  if (uploadedImage) {
    e.preventDefault();
    playSound('clear');
    uploadedImage = null;
    document.getElementById('imageUpload').value = '';
    updateHeaderEmoji(null);
    document.getElementById('uploadIcon').classList.remove('hidden');
    document.getElementById('uploadedIcon').classList.add('hidden');
  }
});

async function generate() {
  const prompt = document.getElementById('prompt').value.trim();
  if (!prompt) {
    showError('please enter a description', { reason: 'empty prompt' }, null, null, null);
    return;
  }

  const btn = document.getElementById('generateBtn');
  const btnText = document.getElementById('btnText');
  const error = document.getElementById('error');
  const rateLimitBanner = document.getElementById('rateLimitBanner');

  playSound('generate');
  startGeneratingMelody();
  btn.disabled = true;
  btnText.textContent = 'generating...';
  error.classList.add('hidden');
  rateLimitBanner.classList.add('hidden');
  hideActions();
  
  showHeaderShimmer(!!uploadedImage);

  try {
    const body = {
      mode: 'image',
      prompt: `Generate a single emoji icon in Apple iOS emoji style based on this description: ${prompt}. Style: minimal, cute, photorealistic 3D render with natural materials (glass, wood, ceramic, metal, fabric, stone, etc.), simplified rounded smooth shapes, vibrant saturated colors, subtle gradients, soft highlights and shadows like classic Apple emoji. Match material to subject ‚Äì use glass for transparent items, wood for organic objects, ceramic for smooth items, metal for tech/tools, fabric for soft items. For people and characters: use simplified cute features with minimal detail. Output on a pure white background (#FFFFFF). Just the object itself, no frame or border.`
    };

    if (uploadedImage) {
      const base64Data = uploadedImage.split(',')[1];
      body.images = [{
        mediaType: 'image/jpeg',
        data: base64Data
      }];
    }

    const actualRequestString = JSON.stringify(body);
    requestData = {
      length: actualRequestString.length,
      preview: actualRequestString.substring(0, 500) + (actualRequestString.length > 500 ? '...' : ''),
      hasImages: !!body.images,
      imageDataLength: body.images ? body.images[0].data.length : 0,
      prompt: body.prompt
    };

    console.log('sending request with body length:', actualRequestString.length);

    const res = await fetch('/api/applet-ai', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    responseData = {
      status: res.status,
      statusText: res.statusText,
      headers: Object.fromEntries(res.headers.entries()),
      contentType: res.headers.get('content-type')
    };

    console.log('response:', responseData);

    if (!res.ok) {
      let errorText = '';
      let errorJson = null;
      try {
        errorText = await res.text();
        console.log('error response body:', errorText);
        responseData.body = errorText;
        try {
          errorJson = JSON.parse(errorText);
        } catch (e) {}
      } catch (e) {
        errorText = 'could not read error response';
        responseData.body = errorText;
      }
      
      const isRateLimited = res.status === 429 || 
                           (errorJson && errorJson.error && 
                            (errorJson.error.toLowerCase().includes('rate limit') || 
                             errorJson.error.toLowerCase().includes('quota') ||
                             errorJson.error.toLowerCase().includes('too many requests')));
      
      throw new Error(`api returned ${res.status} ${res.statusText}`, {
        cause: { ...responseData, isRateLimited, errorJson }
      });
    }

    const blob = await res.blob();
    responseData.blobSize = blob.size;
    responseData.blobType = blob.type;
    
    console.log('blob size:', blob.size, 'type:', blob.type);
    
    const url = URL.createObjectURL(blob);
    generatedImageUrl = url;
    
    stopGeneratingMelody();
    playSound('complete');
    updateHeaderEmoji(url, false);
    showActions();
  } catch (err) {
    console.error('generation failed:', err);
    
    stopGeneratingMelody();
    
    if (uploadedImage) {
      updateHeaderEmoji(uploadedImage, false);
    } else {
      updateHeaderEmoji(null);
    }
    
    const isRateLimited = err.cause && err.cause.isRateLimited;
    const errorJson = err.cause && err.cause.errorJson;
    
    // Ê£ÄÊü•ÊòØÂê¶ÊòØÊ®°ÂûãËøáËΩΩÊàñÂèØÈáçËØïÁöÑÈîôËØØ
    const isRetryable = errorJson && errorJson.retryable;
    const isOverloaded = errorJson && errorJson.error && 
                        (errorJson.error.toLowerCase().includes('overloaded') || 
                         errorJson.error.toLowerCase().includes('try again'));
    
    // ‰ΩøÁî®Êõ¥ÂèãÂ•ΩÁöÑÈîôËØØÊ∂àÊÅØ
    let errorMessage = err.message;
    if (errorJson && errorJson.error) {
      errorMessage = errorJson.error;
    } else if (isOverloaded) {
      errorMessage = 'Model is temporarily overloaded. Please try again in a few moments.';
    }
    
    showError(
      errorMessage,
      {
        name: err.name,
        stack: err.stack,
        cause: err.cause,
        timestamp: new Date().toISOString(),
        retryable: isRetryable,
        overloaded: isOverloaded
      },
      requestData,
      responseData,
      isRateLimited ? errorJson : null
    );
  } finally {
    btn.disabled = false;
    btnText.textContent = 'generate';
  }
}

document.getElementById('generateBtn').addEventListener('click', generate);
document.getElementById('retryBtn').addEventListener('click', generate);

document.getElementById('downloadBtn').addEventListener('click', async () => {
  if (!generatedImageUrl) return;
  
  playSound('click');
  const downloadText = document.getElementById('downloadText');
  const originalText = downloadText.textContent;
  downloadText.textContent = 'downloading...';
  
  try {
    const response = await fetch(generatedImageUrl);
    const blob = await response.blob();
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const promptText = document.getElementById('prompt').value.trim().replace(/[^a-z0-9]/gi, '_').toLowerCase();
    a.download = `emoji_${promptText}.png`;
    a.click();
    URL.revokeObjectURL(url);
    
    downloadText.textContent = 'downloaded!';
    setTimeout(() => {
      downloadText.textContent = originalText;
    }, 2000);
  } catch (error) {
    console.error('download failed:', error);
    downloadText.textContent = 'failed';
    setTimeout(() => {
      downloadText.textContent = originalText;
    }, 2000);
  }
});

document.getElementById('clearBtn').addEventListener('click', resetAll);

function showError(msg, debug, req, res, rateLimitData) {
  const error = document.getElementById('error');
  const errorMsg = document.getElementById('errorMsg');
  const errorDebug = document.getElementById('errorDebug');
  const requestDebug = document.getElementById('requestDebug');
  const responseDebug = document.getElementById('responseDebug');
  const rateLimitBanner = document.getElementById('rateLimitBanner');
  const rateLimitMessage = document.getElementById('rateLimitMessage');
  
  // Â¶ÇÊûúÊòØÂèØÈáçËØïÁöÑÈîôËØØÔºàÂ¶ÇÊ®°ÂûãËøáËΩΩÔºâÔºåÊ∑ªÂä†ÊèêÁ§∫
  const isRetryable = debug && debug.retryable;
  const isOverloaded = debug && debug.overloaded;
  
  if (isOverloaded || isRetryable) {
    errorMsg.innerHTML = msg + '<br><span class="text-xs text-neutral-500 mt-1 block">This is a temporary issue. Click "retry" to try again.</span>';
  } else {
    errorMsg.textContent = msg;
  }
  errorDebug.textContent = JSON.stringify(debug, null, 2);
  
  if (req) {
    requestDebug.textContent = JSON.stringify(req, null, 2);
  } else {
    requestDebug.textContent = 'no request data';
  }
  
  if (res) {
    responseDebug.textContent = JSON.stringify(res, null, 2);
  } else {
    responseDebug.textContent = 'no response data';
  }
  
  if (rateLimitData) {
    const resetSeconds = rateLimitData.resetSeconds || 0;
    const scope = rateLimitData.scope || 'unknown';
    const limit = rateLimitData.limit || 0;
    
    let scopeText = scope;
    if (scope === 'image-hour') {
      scopeText = 'image generation per hour';
    } else if (scope === 'image-day') {
      scopeText = 'image generation per day';
    }
    
    rateLimitMessage.innerHTML = `you've hit the limit of <span class="font-bold">${limit} ${scopeText}</span>. try again in <span class="font-bold">${formatTime(resetSeconds)}</span>. log in via <span class="font-bold">ryOS Chats</span> for higher limits.`;
    rateLimitBanner.classList.remove('hidden');
  } else {
    rateLimitBanner.classList.add('hidden');
  }
  
  error.classList.remove('hidden');
}

document.getElementById('prompt').addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && e.metaKey) {
    e.preventDefault();
    generate();
  }
});

document.getElementById('prompt').focus();
</script>
</body>
</html>